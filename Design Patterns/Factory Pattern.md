# 工厂模式

所有工厂模式都用来`封装对象的创建`。

## Simple Factory （简单工厂模式）

将创建具体实例的过程移动到简单工厂类中的方法，封装创建的过程，即封装了变化的部分，后续改变只需修改该工厂类。它不是一种工厂模式，更多的是一种编程习惯。

### 静态方法实现的简单工厂模式

用静态方法实现的工厂模式，可不用创建工厂的实例即可获取到需要创建的具体实例。但这样有个缺陷，就是不能通过继承来改变工厂的实现。

>  Java的静态方法不能被重写:
> 静态成员（方法或属性）是类的成员存放在栈中，类可以直接调用；实例成员是对象的成员，存放在堆中，只能被对象调用。 
> 重写的目的在于根据创造对象的所属类型不同而表现出多态。因为静态方法无需创建对象即可使用。没有对象，重写所需要的“对象所属类型” 这一要素不存在，因此无法被重写。 

## Factory Method Pattern （工厂方法模式）

**工厂方式模式**：定义了一个创建对象的接口，但由子类来决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

## Dependency Inversion Principle（依赖倒置原则）

**设计原则：**要依赖抽象，而不要依赖具体类

## Abstract Factory Pattern （抽象工厂模式）

**抽象工厂模式：**提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

## 简单工厂模式与工厂方法模式对比

1. 简单工厂模式与工厂方法模式面向是不同的，一个是面向工厂类，而一个是面向工厂方法。
2. 简单工厂使用的是组合。而，工厂方法是通过继承，也因此拥有多态的特性。
3. 工厂方法模式是一个框架，也更具有弹性。

## 工厂方法模式与抽象工厂模式对比

1. 抽象工厂模式与工厂方法模式面向也是不同的，一个是面向工厂类与方法，而一个是面向工厂方法。
2. 抽象工厂使用的是组合加继承。而，工厂方法是通过继承，也因此都拥有多态的特性。
3. 抽象工厂是一个大的接口，定义的可以是一整个产品家族。而工厂方法则定义的是一种产品。
4. 抽象工厂使用时需要先实例化该工厂。然后，将他组合到使用该抽象工厂的类中。